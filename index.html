<!doctype html>

<meta charset="utf-8">
<title>Dagre D3 Renderer</title>

<script src="js/d3.v4.min.js" charset="utf-8"></script>
<script src="js/dagre-d3.js"></script>

<!-- Pull in JQuery dependencies -->
<!---<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.tipsy/1.0.3/jquery.tipsy.css"> -->

<link rel="stylesheet" href="css/jquery.qtip.min.css">
<script src="js/jquery-1.9.1.min.js"></script>
<!---<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.tipsy/1.0.3/jquery.tipsy.css"> -->
<script src="js/jquery.qtip.min.js"></script>
<!---<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tipsy/1.0.3/jquery.tipsy.js"></script>-->

<style id="css">
body {
  font: 300 14px 'Helvetica Neue', Helvetica;
}

.clusters rect {
  fill: #ffffff;
  stroke: #999;
  stroke-width: 1.5px;
}

.node rect,
.node circle,
.node ellipse,
.node polygon, path {
  stroke: #333;
  fill: #fff;
  stroke-width: 1.5px;
}

.edgePath path.path {
  stroke: #333;
  fill: none;
  stroke-width: 1.5px;
}

.qtip {
  min-width: 300px;
}

/* This styles the title of the tooltip */
/* .tipsy .name {
  font-size: 1.5em;
  font-weight: bold;
  color: #60b1fc;
  margin: 0;
} */

/* This styles the body of the tooltip */
/* .tipsy .description {
  font-size: 1.2em;
} */
</style>

<h1>Visualizing Poetic Meter in South Asian Languages</h1>

<script src="js/wavesurfer.js">/*https://unpkg.com*/</script>
<script src="js/wavesurfer.cursor.js"></script>
<svg width=960 height=600><g/></svg>
<div id="waveform"></div>
<div class="controls">
  <button class="btn btn-primary" onclick="wavesurfer.skipBackward()">
    <i class="fa fa-step-backward"></i>
    Backward
  </button>

  <button class="btn btn-primary" onclick="wavesurfer.playPause()">
    <i class="fa fa-play"></i>
    Play
    /
    <i class="fa fa-pause"></i>
    Pause
  </button>

  <button class="btn btn-primary" onclick="wavesurfer.skipForward()">
    <i class="fa fa-step-forward"></i>
    Forward
  </button>

  <button class="btn btn-primary" onclick="wavesurfer.toggleMute()">
    <i class="fa fa-volume-off"></i>
    Toggle Mute
  </button>
</div>


<section>
<p>An example that shows a graph-based scan of an Urdu-Hindi poem ("Bol" by Faiz Ahmed Faiz)  with hover events explaining the meter. Rectangles are long metrical units, circles are short ones.
</section>

<script id="js">
// Create a new directed graph

var base_graph = {"edge": {"0": {"1": {}}, "1": {"2": {}, "3": {}}, "2": {"4": {}}, "3": {"5": {}}, "4": {"6": {}}, "5": {"4": {}}, "6": {"7": {}}, "7": {"8": {}, "9": {}}, "8": {"10": {}}, "9": {"11": {}}, "10": {"12": {}}, "11": {"10": {}}, "12": {"13": {}}}, "node": {"0": {"type": "0"}, "1": {"type": "="}, "2": {"type": "="}, "3": {"type": "-"}, "4": {"type": "="}, "5": {"type": "-"}, "6": {"type": "="}, "7": {"type": "="}, "8": {"type": "="}, "9": {"type": "-"}, "10": {"type": "="}, "11": {"type": "-"}, "12": {"type": "="}, "13": {"type": "Accepting", "id": 0, "name": "Faiz", "regex_pattern": "=(=|--)===(=|--)==", "meter_key": 0}}, "edge_list": [[0, 1], [1, 2], [1, 3], [2, 4], [3, 5], [4, 6], [5, 4], [6, 7], [7, 8], [7, 9], [8, 10], [9, 11], [10, 12], [11, 10], [12, 13]]};

function dagred3_base_graph(active) {
  var g = new dagreD3.graphlib.Graph({compound:false}).setGraph({'rankdir':"lr"})

  for (var i in base_graph.node) {
    node = base_graph.node[i];
    if (node.type==0) {
      if (active) {
        _style = "fill: green;"
      } else {
        _style = "fill: grey;"
      }
      g.setNode(i, {label: 'Start', shape: 'Mdiamond', style: _style, _type:"start", orig_tokens:[]});
    } else if (node.type == 'Accepting') {
      if (active) {
        _style = "fill: red;"
      } else {
        _style = "fill: grey;"
      }
      g.setNode(i, {label: 'End', shape: 'Msquare', style: _style, _type:"end", title:"End Node", orig_tokens:[]});
      g.acceptingNode = i; // Adding attribute
    } else {
      node_shapes = {"=": "rectangle", "-": "circle", "_": "circle"};
      //_label = orig_tokens.join('').replace(/ /g, interpunct);
      _shape = node_shapes[node.type];
      //#node_name = "node_" + match_id; #.style("stroke-width", 1)
      g.setNode(i, {label: '', shape: _shape, style: "stroke:grey; stroke-width: 1; stroke-dasharray: 1,1"});//, orig_tokens:orig_tokens});
    }

  }

  for (var head in base_graph.edge) {
    for (var tail in base_graph.edge[head]) {
      g.setEdge(head, tail,{'style': "stroke:grey; stroke-width: 1; stroke-dasharray: 1,1", arrowhead: "hollowPointInactive"});
    }
  }
  return g;
}
intervals = [[0.0, 4.125714285714288, "cut"], [4.125714285714288, 7.023696449108615, "1"], [8.320000000000002, 11.080045966382015, "2"], [12.651428571428573, 14.756200484663541, "3"], [15.73714285714286, 18.601745013831568, "4"], [19.611428571428576, 22.33145999836452, "5"], [22.33145999836452, 25.150750820636258, "6"], [27.55428571428572, 29.721899445393763, "7"], [30.37714285714286, 32.40006797221399, "8"], [32.994285714285716, 35.62116334050255, "9"], [36.377142857142864, 38.444232142704514, "10"], [39.92, 41.99027150736831, "11"], [43.17714285714286, 46.39093568842475, "12"], [46.39093568842475, 51.2, "cut"]]

lines = ['bol kih lab aazaad hai;n tere',
 'bol zabaa;n ab tak terii hai',
 'teraa sutvaa;n jism hai teraa',
 'bol kih jaa;n ab tak terii hai',
 'dekh kih aahangar kii dukaa;n me;n',
 'tund hai;n shole sur;x hai aahan',
 'khulne lage quflo;n ke dahaane',
 'phailaa har ik zanjiir kaa daaman',
 'bol yih tho;raa vaqt bahut hai',
 'jism-o-zabaa;n kii maut se pahle',
 'bol kih sach zindah hai ab tak',
 'bol jo kuchh kahnaa hai kah le']

scans = {"1": [["=--===--==", [["=", ["b", "c", "v"], 1, [" ", "b", "o"], "l_bcv", 0, 0], ["-", ["c"], 3, ["l"], "s_c", 3, 1], ["-", ["b", "nah"], 5, [" ", "k", "i", "h"], "s_bnah", 4, 3], ["=", ["b", "c", "s", "c"], 4, [" ", "l", "a", "b"], "l_bcsc", 6, 5], ["=", ["b", "v"], 6, [" ", "aa"], "l_bv", 10, 4], ["=", ["c", "v"], 7, ["z", "aa"], "l_cv", 12, 6], ["-", ["c"], 9, ["d"], "s_c", 14, 7], ["-", ["b", "c", "v", "n"], 11, [" ", "h", "ai", ";n"], "s_bcvn<b>", 15, 9], ["=", ["b", "c", "v"], 10, [" ", "t", "e"], "l_bcv", 19, 11], ["=", ["c", "v"], 12, ["r", "e"], "l_cv", 22, 10]], 0]], "2": [["=--======", [["=", ["b", "c", "v"], 1, [" ", "b", "o"], "l_bcv", 0, 0], ["-", ["c"], 3, ["l"], "s_c", 3, 1], ["-", ["b", "c", "s"], 5, [" ", "z", "a"], "s_bcs", 4, 3], ["=", ["c", "v", "n<(aa)wb>"], 4, ["b", "aa", ";n"], "l_cvn<(aa)wb>", 7, 5], ["=", ["b", "s", "c"], 6, [" ", "a", "b"], "l_bsc", 10, 4], ["=", ["b", "c", "s", "c"], 7, [" ", "t", "a", "k"], "l_bcsc", 13, 6], ["=", ["b", "c", "v"], 8, [" ", "t", "e"], "l_bcv", 17, 7], ["=", ["c", "v"], 10, ["r", "ii"], "l_cv", 20, 8], ["=", ["b", "c", "v"], 12, [" ", "h", "ai"], "l_bcv", 22, 10]], 0]], "3": [["=====--==", [["=", ["b", "c", "v"], 1, [" ", "t", "e"], "l_bcv", 0, 0], ["=", ["c", "v"], 2, ["r", "aa"], "l_cv", 3, 1], ["=", ["b", "c", "s", "c"], 4, [" ", "s", "u", "t"], "l_bcsc", 5, 2], ["=", ["c", "v", "n<(aa)wb>"], 6, ["v", "aa", ";n"], "l_cvn<(aa)wb>", 9, 4], ["=", ["b", "c", "s", "c"], 7, [" ", "j", "i", "s"], "l_bcsc", 12, 6], ["-", ["c"], 9, ["m"], "s_c", 16, 7], ["-", ["b", "c", "v"], 11, [" ", "h", "ai"], "s_bcv<b>", 17, 9], ["=", ["b", "c", "v"], 10, [" ", "t", "e"], "l_bcv", 20, 11], ["=", ["c", "v"], 12, ["r", "aa"], "l_cv", 23, 10]], 0]], "4": [["=--======", [["=", ["b", "c", "v"], 1, [" ", "b", "o"], "l_bcv", 0, 0], ["-", ["c"], 3, ["l"], "s_c", 3, 1], ["-", ["b", "nah"], 5, [" ", "k", "i", "h"], "s_bnah", 4, 3], ["=", ["b", "c", "v", "n<(aa)wb>"], 4, [" ", "j", "aa", ";n"], "l_cvn<(aa)wb>", 6, 5], ["=", ["b", "s", "c"], 6, [" ", "a", "b"], "l_bsc", 10, 4], ["=", ["b", "c", "s", "c"], 7, [" ", "t", "a", "k"], "l_bcsc", 13, 6], ["=", ["b", "c", "v"], 8, [" ", "t", "e"], "l_bcv", 17, 7], ["=", ["c", "v"], 10, ["r", "ii"], "l_cv", 20, 8], ["=", ["b", "c", "v"], 12, [" ", "h", "ai"], "l_bcv", 22, 10]], 0]], "5": [["=--===--==", [["=", ["b", "c", "v"], 1, [" ", "d", "e"], "l_bcv", 0, 0], ["-", ["c"], 3, ["kh"], "s_c", 3, 1], ["-", ["b", "nah"], 5, [" ", "k", "i", "h"], "s_bnah", 4, 3], ["=", ["b", "v"], 4, [" ", "aa"], "l_bv", 6, 5], ["=", ["c", "s", "c"], 6, ["h", "a", "n"], "l_csc", 8, 4], ["=", ["c", "s", "c"], 7, ["g", "a", "r"], "l_csc", 11, 6], ["-", ["b", "c", "v"], 9, [" ", "k", "ii"], "s_bcv<b>", 14, 7], ["-", ["b", "c", "s"], 11, [" ", "d", "u"], "s_bcs", 17, 9], ["=", ["c", "v", "n<(aa)wb>"], 10, ["k", "aa", ";n"], "l_cvn<(aa)wb>", 20, 11], ["=", ["b", "c", "v", "n"], 12, [" ", "m", "e", ";n"], "l_bcvn", 23, 10]], 0]], "6": [["=--===--==", [["=", ["b", "c", "s", "c"], 1, [" ", "t", "u", "n"], "l_bcsc", 0, 0], ["-", ["c"], 3, ["d"], "s_c", 4, 1], ["-", ["b", "c", "v", "n"], 5, [" ", "h", "ai", ";n"], "s_bcvn<b>", 5, 3], ["=", ["b", "c", "v"], 4, [" ", "sh", "o"], "l_bcv", 9, 5], ["=", ["c", "v"], 6, ["l", "e"], "l_cv", 12, 4], ["=", ["b", "c", "s", "c"], 7, [" ", "s", "u", "r"], "l_bcsc", 14, 6], ["-", ["c"], 9, [";x"], "s_c", 18, 7], ["-", ["b", "c", "v"], 11, [" ", "h", "ai"], "s_bcv<b>", 19, 9], ["=", ["b", "v"], 10, [" ", "aa"], "l_bv", 22, 11], ["=", ["c", "s", "c"], 12, ["h", "a", "n"], "l_csc", 24, 10]], 0]], "7": [["=--===--==", [["=", ["b", "c", "s", "c"], 1, [" ", "kh", "u", "l"], "l_bcsc", 0, 0], ["-", ["c", "v"], 3, ["n", "e"], "s_cv<b>", 4, 1], ["-", ["b", "c", "s"], 5, [" ", "l", "a"], "s_bcs", 6, 3], ["=", ["c", "v"], 4, ["g", "e"], "l_cv", 9, 5], ["=", ["b", "c", "s", "c"], 6, [" ", "q", "u", "f"], "l_bcsc", 11, 4], ["=", ["c", "v", "n"], 7, ["l", "o", ";n"], "l_cvn", 15, 6], ["-", ["b", "c", "v"], 9, [" ", "k", "e"], "s_bcv<b>", 18, 7], ["-", ["b", "c", "s"], 11, [" ", "d", "a"], "s_bcs", 21, 9], ["=", ["c", "v"], 10, ["h", "aa"], "l_cv", 24, 11], ["=", ["c", "v"], 12, ["n", "e"], "l_cv", 26, 10]], 0]], "8": [["=--===--==", [["=", ["b", "c", "v"], 1, [" ", "ph", "ai"], "l_bcv", 0, 0], ["-", ["c", "v"], 3, ["l", "aa"], "s_cv<b>", 3, 1], ["-", ["b", "c", "s"], 5, [" ", "h", "a"], "s_bcs", 5, 3], ["=", ["c", "b", "s", "c"], 4, ["r", " ", "i", "k"], "l_cbsc", 8, 5], ["=", ["b", "c", "s", "c"], 6, [" ", "z", "a", "n"], "l_bcsc", 12, 4], ["=", ["c", "v"], 7, ["j", "ii"], "l_cv", 16, 6], ["-", ["c"], 9, ["r"], "s_c", 18, 7], ["-", ["b", "c", "v"], 11, [" ", "k", "aa"], "s_bcv<b>", 19, 9], ["=", ["b", "c", "v"], 10, [" ", "d", "aa"], "l_bcv", 22, 11], ["=", ["c", "s", "c"], 12, ["m", "a", "n"], "l_csc", 25, 10]], 0]], "9": [["=--===--==", [["=", ["b", "c", "v"], 1, [" ", "b", "o"], "l_bcv", 0, 0], ["-", ["c"], 3, ["l"], "s_c", 3, 1], ["-", ["b", "c", "s", "c<h+wb>"], 5, [" ", "y", "a", "h"], "s_bcsc<h+wb>", 4, 3], ["=", ["b", "c", "v"], 4, [" ", "th", "o"], "l_bcv", 8, 5], ["=", ["c", "v"], 6, [";r", "aa"], "l_cv", 11, 4], ["=", ["b", "c", "s", "c"], 7, [" ", "v", "a", "q"], "l_bcsc", 13, 6], ["-", ["c"], 9, ["t"], "s_c", 17, 7], ["-", ["b", "c", "s"], 11, [" ", "b", "a"], "s_bcs", 18, 9], ["=", ["c", "s", "c"], 10, ["h", "u", "t"], "l_csc", 21, 11], ["=", ["b", "c", "v"], 12, [" ", "h", "ai"], "l_bcv", 24, 10]], 0]], "10": [["=--===--==", [["=", ["b", "c", "s", "c"], 1, [" ", "j", "i", "s"], "l_bcsc", 0, 0], ["-", ["c", "o"], 3, ["m", "-o-"], "s_co", 4, 1], ["-", ["c", "s"], 5, ["z", "a"], "s_cs", 6, 3], ["=", ["c", "v", "n<(aa)wb>"], 4, ["b", "aa", ";n"], "l_cvn<(aa)wb>", 8, 5], ["=", ["b", "c", "v"], 6, [" ", "k", "ii"], "l_bcv", 11, 4], ["=", ["b", "c", "v"], 7, [" ", "m", "au"], "l_bcv", 14, 6], ["-", ["c"], 9, ["t"], "s_c", 17, 7], ["-", ["b", "c", "v"], 11, [" ", "s", "e"], "s_bcv<b>", 18, 9], ["=", ["b", "c", "s", "c"], 10, [" ", "p", "a", "h"], "l_bcsc", 21, 11], ["=", ["c", "v"], 12, ["l", "e"], "l_cv", 25, 10]], 0]], "11": [["=--======", [["=", ["b", "c", "v"], 1, [" ", "b", "o"], "l_bcv", 0, 0], ["-", ["c"], 3, ["l"], "s_c", 3, 1], ["-", ["b", "nah"], 5, [" ", "k", "i", "h"], "s_bnah", 4, 3], ["=", ["b", "c", "s", "c"], 4, [" ", "s", "a", "ch"], "l_bcsc", 6, 5], ["=", ["b", "c", "s", "c"], 6, [" ", "z", "i", "n"], "l_bcsc", 10, 4], ["=", ["c", "s", "c<h+wb>"], 7, ["d", "a", "h"], "l_csc<h+wb>", 14, 6], ["=", ["b", "c", "v"], 8, [" ", "h", "ai"], "l_bcv", 17, 7], ["=", ["b", "s", "c"], 10, [" ", "a", "b"], "l_bsc", 20, 8], ["=", ["b", "c", "s", "c"], 12, [" ", "t", "a", "k"], "l_bcsc", 23, 10]], 0]], "12": [["=--======", [["=", ["b", "c", "v"], 1, [" ", "b", "o"], "l_bcv", 0, 0], ["-", ["c"], 3, ["l"], "s_c", 3, 1], ["-", ["b", "c", "v"], 5, [" ", "j", "o"], "s_bcv<b>", 4, 3], ["=", ["b", "c", "s", "c"], 4, [" ", "k", "u", "chh"], "l_bcsc", 7, 5], ["=", ["b", "c", "s", "c"], 6, [" ", "k", "a", "h"], "l_bcsc", 11, 4], ["=", ["c", "v"], 7, ["n", "aa"], "l_cv", 15, 6], ["=", ["b", "c", "v"], 8, [" ", "h", "ai"], "l_bcv", 17, 7], ["=", ["b", "c", "s", "c<h+wb>"], 10, [" ", "k", "a", "h"], "l_bcsc<h+wb>", 20, 8], ["=", ["b", "c", "v"], 12, [" ", "l", "e"], "l_bcv", 24, 10]], 0]]}

var node_names = {"=": "Long", "-": "Short", "_": "Uncounted Short",
                  "start": "Start", "end": "End"}

/*
      orig_tokens = node.orig_tokens
      if (node_type == "start" || node_type == "end") {
        name = node_name;
      } else {
        name = node_name + " " + " (<em>"+node.orig_tokens.join("").replace(" ", interpunct)+"</em>)"
      }
      description = htmlEntities(node.rule_found);
      description = verbose(v, node.rule_found, node.orig_tokens);
      //this.title = "BOSS";//"<p class='name'>" + name + "</p><p class='description'>" + description + "</p>";
      //this.title = title;//"TITLE";
      $(this).qtip({
        content: {
          text: description,
          title: name},

        position: {
          my: 'top left',  // Position my top left...
          at: 'bottom left'
        },
        // style: {
        //   classes: 'qtip-blue qtip-shadow'
        // }
      })
  });
}*/
function dagred3_of_scan_result(scan_result){
  [scan, matches, meter_key] = scan_result[0]; // an array?
  g = dagred3_base_graph(true);
  for (var match_id in matches ) {
    match = matches[match_id];
    [type, matched_tokens, node_key, orig_tokens, rule_found, token_i, parent_key] = match
    interpunct = "·"
    _label = orig_tokens.join('').replace(/ /g, interpunct);
    console.log(match);
    node_shapes = {"=": "rectangle", "-": "circle", "_": "circle"};
    node_name = node_names[type];
    _shape = node_shapes[type];
    g.setNode(node_key,
      {"label":_label,
       "shape": _shape,
       "style": "stroke:black; stroke-width: 2; stroke-dash-array:1,0",
       "name": node_name,
       "orig_tokens": orig_tokens,
       "rule_found": rule_found,
       "token_i": token_i,
       "parent_key": parent_key,
       "_type": type,
       });
    g.setEdge(parent_key, node_key, {'style': 'stroke:black; stroke-width: 2; stroke-dasharray: 1,0'});
  }
  g.setEdge(node_key, g.acceptingNode, {'style': 'stroke:black; stroke-width: 2; stroke-dasharray: 1,0'});

  x = 1;
  return g;
}

g_scans = {'cut': dagred3_base_graph()}
for (var line_id in scans){
  g_scans[line_id] = dagred3_of_scan_result(scans[line_id]);
}

//
// result = ["=-==/=-==/=-==/=-=", [["=", "l_bcsc", [" ", "n", "a", "q"]], ["-", "s_c", ["sh"]], ["=", "l_bcsc", [" ", "f", "a", "r"]], ["=", "l_cv", ["y", "aa"]], ["=", "l_cv", ["d", "ii"]], ["-", "s_bcv<b>", [" ", "h", "ai"]], ["=", "l_bcsc", [" ", "k", "i", "s"]], ["=", "l_bcv", [" ", "k", "ii"]], ["=", "l_bcv", [" ", "sh", "o"]], ["-", "s_cv<ii+z>", [";x", "ii"]], ["=", "l_z", ["-", "e"]], ["=", "l_bcsc", [" ", "t", "a", ";h"]], ["=", "l_cv", ["r", "ii"]], ["-", "s_c", ["r"]], ["=","l_bcv", [" ", "k", "aa"]]], 9];
// [scan, matches, meter_key] = result

/*g.setNode("start", {label: 'Start', shape: 'Mdiamond', style: "fill: green", _type:"start", orig_tokens:[]});
g.setNode("end", {label: 'End', shape: 'Msquare', style: "fill: red", _type:"end", title:"End Node", orig_tokens:[]});

prev = "start";

node_shapes = {"=": "rectangle", "-": "circle", "_": "circle"};

for (i=0; i<scan.length; i++) {
  _ = scan[i];
  if (_ == '/'){
    cluster_id += 1;
    continue;
  }
  cluster_name = cluster_names[cluster_id];
  match_id += 1;
  var _match = matches[match_id];
  [_type, rule_found, orig_tokens] = _match;
  interpunct = " ·"
  _label = orig_tokens.join('').replace(/ /g, interpunct);
  _shape = node_shapes[_type];
  node_name = "node_" + match_id;
  g.setNode(node_name, {label: _label, shape: _shape, _type:_type, rule_found :rule_found, orig_tokens:orig_tokens});
  if (_type != '_') {
    g.setParent(node_name, cluster_name)
  }
  g.setEdge(prev, node_name, {arrowhead: "hollowPoint"})
  prev = node_name
}

g.setEdge(prev, "end", {arrowhead: "hollowPoint"});

/*
g.setNode("l1", { shape: "oblong", label: "=", style:"fill: #afa" });
g.setNode("c1", { shape: "circle", label: "-" });
g.setNode("l2", { shape: "oblong", label: "=" });
g.setNode("l3", { shape: "oblong", label: "=" });
g.setNode("l3", { shape: "square", label: "end" })
g.setNode("d1", { shape: "diamond", label: "end", style:"fill: #afa" });
g.setNode("msq1", { shape: "Msquare", label: "End", style: "fill: #afa" });
g.setNode("mdm1", { shape: "Mdiamond", label: "Start", style: "fill: #afa"   });
g.setEdge("l1", "c1", { arrowhead: "hollowPoint" });
g.setEdge("c1", "l2", { arrowhead: "hollowPoint" });
g.setEdge("l2", "l3", { arrowhead: "hollowPoint" });
*/
var svg = d3.select("svg");
var inner = svg.select("g");
/*
// Set up zoom support
var zoom = d3.zoom().on("zoom", function() {
    inner.attr("transform", d3.event.transform);
  });
svg.call(zoom);
*/
// Create the renderer
var render = new dagreD3.render();

render.shapes().rectangle = function(parent, bbox, node) {
  var w = Math.max(bbox.width, bbox.height*1.5),
      shapeSvg = parent.insert("rect", ":first-child")
        .attr("rx", node.rx)
        .attr("ry", node.ry)
        .attr("x", -w / 2)
        .attr("y", -bbox.height / 2)
        .attr("width", w)
        .attr("height", bbox.height);

  node.intersect = function(point) {
    return dagreD3.intersect.rect(node, point);
  };
  return shapeSvg;
}

intersectRect = dagreD3.intersect.rect;
intersectPolygon = dagreD3.intersect.polygon;

render.shapes().square = function(parent, bbox, node) {
  var l = Math.max(bbox.width, bbox.height),
      shapeSvg = parent.insert("rect", ":first-child")
        .attr("rx", node.rx)
        .attr("ry", node.ry)
        .attr("x", -l / 2)
        .attr("y", -l / 2)
        .attr("width", l)
        .attr("height", l);

  node.intersect = function(point) {
    return intersectRect(node, point);
  };
  return shapeSvg;
}

render.shapes().Mdiamond = function(parent, bbox, node) {
  var w = (bbox.width * Math.SQRT2) / 2,
      h = (bbox.height * Math.SQRT2) / 2,
      c = Math.sqrt(w **2 + h **2), // hypotenuse
      points = [
        { x:  0, y: -h },
        { x: -w, y:  0 },
        { x:  0, y:  h },
        { x:  w, y:  0 }
      ],
      shapeSvg = parent.insert("polygon", ":first-child")
        .attr("points", points.map(function(p) { return p.x + "," + p.y; }).join(" ")),
      theta_1 = Math.asin(h/c),
      theta_2 = Math.asin(w/c),
      y = Math.sin(theta_1) * c / 3,
      x = Math.sin(theta_2) * c / 3,
      paths = [
         { mx: -x,   my: -h + y,
           lx: x,    ly: -h + y},
         { mx: w-x,  my: -y,
           lx: w-x,  ly: y},
         { mx: -x,   my: h - y,
           lx: x,    ly: h - y},
         { mx: -w+x,  my: -y,
           lx: -w+x,  ly: y}
      ];
      var diagonalsSvg = parent.append("path")
          .attr("d", paths.map(
            function(d) {
              return "M "+d.mx + " " + d.my + " " +
                     "L "+d.lx + " " + d.ly + " "
            }
          ).join(" "));

  node.intersect = function(p) {
    return intersectPolygon(node, points, p);
  };

  return shapeSvg;
}


render.shapes().Msquare = function (parent, bbox, node) {

  var l = Math.max(bbox.width, bbox.height),
      diagOffset = l / 3; // diagonal offset

  var shapeSvg = parent.insert("rect", ":first-child")
        .attr("rx", node.rx)
        .attr("ry", node.ry)
        .attr("x", -l / 2)
        .attr("y", -l / 2)
        .attr("width", l)
        .attr("height", l);

   paths = [
    { mx: -l/2,            my: -l/2+diagOffset,
      lx: -l/2+diagOffset, ly: -l/2},
    { mx: l/2-diagOffset,  my: -l/2,
      lx: l/2,             ly: -l/2+diagOffset },
    { mx: l/2,             my: l/2-diagOffset,
      lx: l/2-diagOffset,  ly: l/2},
    { mx: -l/2+diagOffset, my: l/2,
      lx: -l/2,            ly: l/2-diagOffset}

    ];

  var diagonalsSvg = parent.append("path")
    .attr("d", paths.map(
      function(d) {
        return "M "+d.mx + " " + d.my + " " +
               "L "+d.lx + " " + d.ly + " "
      }
    ).join(" "));

  node.intersect = function(point) {
    return intersectRect(node, point);
  };

  return shapeSvg;
}


// Add our custom arrow (a hollow-point)
render.arrows().hollowPointInactive = function normal(parent, id, edge, type) {
  var marker = parent.append("marker")
    .attr("id", id)
    .attr("viewBox", "0 0 10 10")
    .attr("refX", 9)
    .attr("refY", 5)
    .attr("markerUnits", "strokeWidth")
    .attr("markerWidth", 8)
    .attr("markerHeight", 6)
    .attr("orient", "auto");

  var path = marker.append("path")
    .attr("d", "M 0 0 L 10 5 L 0 10 z")
    .style("stroke-width", 1)
    .style("stroke-dasharray", "1, 0")
    .style("fill", "grey")
    .style("stroke", "grey"); // fill was #FFF; .style("stroke-dasharray", "1,1")
  dagreD3.util.applyStyle(path, edge[type + "Style"]);
};

// Run the renderer. This is what draws the initial graph.
g = g_scans['cut'];

render(inner, g);//_scans['cut']);/*_scans['cut']);*/
svg.attr('width', g.graph().width);
svg.attr('height', g.graph().height);
/* */



var styleTooltip = function(name, description) {
  return "<p class='name'>" + name + "</p><p class='description'>" + description + "</p>";
};

function htmlEntities(str) {
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}
function em(s){
  return " (<strong>"+s+"</strong) ";
}
explication = {"l_bcsc": "At the start of a word, a consonant {1} followed by a short vowel {2} and another consonant {3} is long. If the second consonant {3} was followed by a vowel, a long unit would not be possible here.", "l_bcsc<h+wb>": "A consonant {1} followed by a short vowel {2} and a pronounced {3} is long.", "l_bcv": "A consonant {1} followed by a long vowel {2} can always be long. At the end of a word, this combination could be short.", "l_bcvn": "A consonant {1} followed by a nasalized long vowel {2}{3} can always be long. At the end of a word, this combination could be short.", "l_bsc": "At the start of a word, a short vowel {0} followed by a consonant {1} is long.", "l_bv": "A long vowel {1} at the start of a word is long. It could also join with the consonant of a preceding word to form a long or short unit.", "l_cbsc": "A consonant {0} at the end of a word joins with a short vowel {2} and a consonant {3} at the start of a next word to form a long unit.", "l_csc": "A consonant {0} followed by short vowel {1} and another consonant {2} is long.", "l_csc<h+wb>": "A consonant {0} followed by a short vowel {1} and a pronounced consonant {2} is long.", "l_cv": "A consonant {0} followed by a long vowel {1} can always be long. At the end of a word, it could be short.", "l_cvn": "A consonant {0} followed by a nasalized long vowel {1}{2} here is long. At the end of a word, it could be short.", "l_cvn<(aa)wb>": "A consonant {0} followed by a nasalized long vowel {1}{2} at the end of a word can be long. The nasalization could have happened for the meter.", "s_bcs": "At the start of a word, a short vowel {0} followed by a consonant {1} is short. If this were followed by a consonant at the end of a word or a cluster a cluster of consonants, this short unit would not be possible.", "s_bcsc<h+wb>": "Here a consonant {1} followed by short vowel {2} and an unpronounced {3} is short.", "s_bcv<b>": "A consonant {1} followed by a long vowel {2} at the end of a word is shortened. This combination could also be long.", "s_bcvn<b>": "A consonant {1} followed by a nasalized long vowel {2} at the end of a word is shortened. This combination could also be long.", "s_bnah": "A consonant {0} followed by a short vowel {1} and an unpronounced {2} is short.", "s_c": "The consonant {0} is short, as it is not followed by vowel or preceded by a short vowel.", "s_co": "The consonant {0} followed by the conjunction {1} here is short. This combination could also be long.", "s_cs": "The consonant {0} followed by the short vowel {1} is short.  If this were followed by a consonant at the end of a word or a cluster of consonants, this short unit would not be possible.", "s_cv<b>": "At the end of a word, a consonant {0} followed by a long vowel {1} is shortened. This combination could also be long."};

function verbose(node_id, rule_found, ot){
  function em(x){
    if (typeof(x) != "object") { /* change to check i farray?*/
      x = [x];
    }
    out = "(<strong>";

    for (i=0;i<x.length;i++) {
      out += ot[x[i]];
    }
    out += "</strong>)";
    return out;
  }

  text = explication[rule_found];
  if (!text) {
    return "Missing";
    console.log("missing explication for "+rule_found);
  }

  for (i=0;i<ot.length;i++) {
    text = text.replace(new RegExp("\\{"+i+"\\}", 'g'), "<strong>"+ot[i]+"</strong>");
  }
  text = text.replace(new RegExp("</strong><strong>", 'g'), "");
  return text;
}

var node_names = {"=": "Long", "-": "Short", "_": "Uncounted Short",
                  "start": "Start", "end": "End"}

function add_qtips() {
  inner.selectAll("g.node")
    .each(function(v) {

      g = g_scans[currSection];

      node = g.node(v);
      if (node) {
        node_type = node._type;
        node_name = node_names[node._type];
        orig_tokens = node.orig_tokens
        name = node_name;
        if (orig_tokens) {
          name +=  " (<em>"+node.orig_tokens.join("").replace(" ", interpunct)+"</em>)"
        }
        if (node.rule_found) {
          name += " /"+node.rule_found+"/"+orig_tokens;
        }
        // if (node_type == "start" || node_type == "end") {
        //   name = node_name;
        // } else {
        //
        //   name = node_name + " " + " (<em>"+node.orig_tokens.join("").replace(" ", interpunct)+"</em>)"
        // }
        /*description = htmlEntities(node.rule_found);*/
        description = '';
        if (node.rule_found){
          description = verbose(node_name, node.rule_found, node.orig_tokens);
        }
        //this.title = "BOSS";//"<p class='name'>" + name + "</p><p class='description'>" + description + "</p>";
        //this.title = title;//"TITLE";
        $(this).qtip({
          content: {
            text: description,
            title: name},

          position: {
            my: 'top left',  // Position my top left...
            at: 'bottom left'
          },
          // style: {
          //   classes: 'qtip-blue qtip-shadow'
          // }
        })
      }
  });
}
// add titles

//$('[title]').qtip(); /* apply qtip to all titles. */

svg.attr('width', g.graph().width);
svg.attr('height', g.graph().height);// * initialScale + 40);

/* wavesurfer */

var wavesurfer = WaveSurfer.create({
    container: '#waveform',
    waveColor: '0DB14B',
    progressColor: '18453B',
     scrollParent: true
});


var currSection = '';

function getSection(time) {
  for (i = 0; i < intervals.length; i++) {
    [start, end, label] = intervals[i];
    if (time >= start && time <= end) {
      return label;
    }
  }
  return "cut";
}

var onProgress = function(time) {
  var x = time;
  section = getSection(x);
  if (section != currSection) {
    g = g_scans[section];
    render(inner, g);//_scans[section]);

    svg.attr('width', g.graph().width);
    svg.attr('height', g.graph().height);// * initialScale + 40);


    currSection = section;
    add_qtips();
  }
};
    // x = time;
    // if (x >=10 && x < 25) {
    //   currGraph =
    // }

var onSeek = function(x) {
  var time = window.wavesurfer.getCurrentTime();
  onProgress(time);
  /*alert('hi');*/
}

wavesurfer.on('audioprocess', onProgress);
wavesurfer.on('seek', onSeek);
/*wavesurfer.on('audioprocess', onProgress);*/

wavesurfer.load('audio/faiz_bol.wav');
</script>
